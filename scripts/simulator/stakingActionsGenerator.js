const web3 = require("web3");
const BN = web3.utils.BN;
const BASE = 100; // base for weighted operations

//next operation options.
const DEPOSIT = 'deposit';
const DELEGATE = 'delegate';
const WITHDRAW = 'withdraw';
const NO_ACTION = 'null';

module.exports = { DEPOSIT, DELEGATE, WITHDRAW, NO_ACTION }

module.exports.genNextOp = function genNextOp() {
    let rand = genRandomSeed(7, BASE);
    // weighted operations
    if (rand < 30) return DEPOSIT;
    if (rand < 60) return WITHDRAW;
    if (rand < 85) return DELEGATE;
    return NO_ACTION;
}

// 97%: amount should be smaller than staker balance
// 3%: should be bigger than staker balance
module.exports.genDeposit = async function genDeposit(kncToken, stakers) {
    let result = {
        'staker': '',
        'amount': 0,
        'msg': '',
        'isValid': false
    }

    let rand = genRandomSeed(32, staker.length);
    result.staker = stakers[rand];
    let tokenBal = (await kncToken.balanceOf(result.staker)).toNumber();
    rand = genRandomSeed(32, BASE);
    if (rand <= 97) {
        result.amount = new BN(genRandomInt(0, tokenBal));
        result.msg = 'valid deposit';
        result.isValid = true;
    } else {
        result.amount = new BN(genRandomInt(tokenBal + 1, tokenBal * 2));
        result.msg = 'invalid deposit';
        result.isValid = false;
    }
    return result;
}

// 60%: Delegate to another address generated by buidler / ganache
// 5%: Delegate to non-staker
// 35%: Delegate back to self (un-delegate)
module.exports.genDelegate = async function genDelegate(stakers) {
    let result = {
        'staker': '',
        'delegatedAddress': '',
        'msg': ''
    }

    let rand = genRandomSeed(32, stakers.length);
    result.staker = stakers[rand];
    // by default, set to self (un-delegate)
    result.delegatedAddress = result.staker;
    result.msg = 'delegate to self';
    rand = genRandomSeed(32, BASE);
    if (rand <= 60) {
        while (result.staker == result.delegatedAddress) {
            let rand2 = genRandomSeed(32, stakers.length);
            result.delegatedAddress = stakers[rand2];
        }
        result.msg = 'delegate to another staker';
    } else if (rand <= 65) {
        let randomPrivateKey = web3.utils.sha3("Katalyst gonna be dope" + rand);
        result.delegatedAddress = web3.eth.accounts.privateKeyToAccount(randomPrivateKey);
        result.msg = 'delegate to non-staker';
    }
    return result;
}

// 44%: Withdraw amount less than deposit amt made so far
// 44%: Withdraw amount greater than deposit made so far
// 2%: Withdraw amount greater than full stake amount
module.exports.genWithdraw = async function genWithdraw(stakingContract, stakers) {
    let result = {
        'staker': '',
        'amount': 0,
        'msg': '',
        isValid = false
    }

    let rand = genRandomSeed(32, stakers.length);
    result.staker = stakers[rand];
    rand = genRandomSeed(32, BASE);
    let latestStake = await stakingContract.methods.getLatestStakeBalance(result.staker);
    let curEpochNum = await stakingContract.methods.getCurrentEpochNumber();
    let curEpochStake = await stakingContract.methods.getStake(result.staker, curEpochNum);
    let depositMadeInCurEpoch = (latestStake.sub(curEpochStake)).toNumber();
    if (rand <= 44) {
        result.amount = new BN(genRandomInt(0, depositMadeInCurEpoch));
        result.msg = 'withdrawal <= deposit so far';
        result.isValid = true;
    } else if (rand <= 88) {
        result.amount = new BN(genRandomInt(depositMadeInCurEpoch.add(new BN(1)), latestStake.toNumber()));
        result.msg = 'withdrawal > deposit so far';
        result.isValid = true;
    } else {
        result.amount = new BN(latestStake.toNumber() + 1, latestStake.toNumber() * 2);
        result.msg = 'withdrawal > stake';
        result.isValid = false;
    }

    return result;
}

function genRandomSeed(length, base) {
    return (web3.utils.randomHex(length)) % base;
}
function genRandomInt(min, max) {
    min = Math.ceil(min);
    max = Math.floor(max);
    return Math.floor(Math.random() * (max - min + 1)) + min;
}
